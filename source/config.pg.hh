/*
 * This is free and unencumbered software released into the public domain.
 *
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 *
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * For more information, please refer to <http://unlicense.org>
 */

// AUTO-GENERATED FILE. DO NOT EDIT!
// Generated by the protogen 2.1.0 compiler <https://github.com/brunexgeek/protogen>
// Source: /media/dados/github/dnsblocker/source/config.proto

#ifndef GUARD__source_config_proto
#define GUARD__source_config_proto

#include <string>
#include <stdint.h>
#include <iterator>
#include <sstream>
#include <iostream>
#include <vector>
#include <list>
#include <utility>
#include <stdexcept>
#include <forward_list>

#ifndef PROTOGEN_2_1_0
    #error Missing include of protogen 2.1.0 header
#endif

//
// NameServer
//
    struct NameServer_type
    {
        std::string address;
        std::vector<std::string> targets;
        std::string name;
    };
namespace protogen_2_1_0 {
template<> struct json< ::NameServer_type>
{
    static int read( json_context &ctx,  ::NameServer_type &value ) { return read_object(ctx, value); }
    static int read_field( json_context &ctx, const std::string &name,  ::NameServer_type &value ) \
    {
        PG_DIF_EX(0,address,"address")
        PG_DIF_EX(1,targets,"targets")
        PG_DIF_EX(2,name,"name")
        return PGR_NIL;
    }
    static void write( json_context &ctx, const  ::NameServer_type &value )
    {
        bool first = true;
        (*ctx.os) << '{';
        PG_SIF_EX(address,"address")
        PG_SIF_EX(targets,"targets")
        PG_SIF_EX(name,"name")
        (*ctx.os) << '}';
    }
    static bool empty( const  ::NameServer_type &value )
    {
        if (!json<decltype(value.address)>::empty(value.address)) return false;
        if (!json<decltype(value.targets)>::empty(value.targets)) return false;
        if (!json<decltype(value.name)>::empty(value.name)) return false;
        return true;
    }
    static void clear(  ::NameServer_type &value )
    {
        json<decltype(value.address)>::clear(value.address);
        json<decltype(value.targets)>::clear(value.targets);
        json<decltype(value.name)>::clear(value.name);
    }
    static bool equal( const  ::NameServer_type &a, const  ::NameServer_type &b )
    {
        if (!json<decltype(a.address)>::equal(a.address, b.address)) return false;
        if (!json<decltype(a.targets)>::equal(a.targets, b.targets)) return false;
        if (!json<decltype(a.name)>::equal(a.name, b.name)) return false;
        return true;
    }
    static void swap(  ::NameServer_type &a,  ::NameServer_type &b )
    {
        json<decltype(a.address)>::swap(a.address, b.address);
        json<decltype(a.targets)>::swap(a.targets, b.targets);
        json<decltype(a.name)>::swap(a.name, b.name);
    }
    static bool is_missing( json_context &ctx )
    {
        std::string name;
        if (!(ctx.mask & 1)) { name = "address"; } else
        if (!(ctx.mask & 2)) { name = "targets"; } else
        if (!(ctx.mask & 4)) { name = "name"; } else
        return false;
        ctx.tok->error(PGERR_MISSING_FIELD, std::string("Missing field '") + name + "'");
        return true;
    }
};}
PG_ENTITY(NameServer, ::NameServer_type,protogen_2_1_0::json< ::NameServer_type>)
PG_ENTITY_SERIALIZER( ::NameServer, ::NameServer_type,protogen_2_1_0::json< ::NameServer_type>)

//
// Binding
//
    struct Binding_type
    {
        std::string address;
        protogen_2_1_0::field<uint32_t> port;
    };
namespace protogen_2_1_0 {
template<> struct json< ::Binding_type>
{
    static int read( json_context &ctx,  ::Binding_type &value ) { return read_object(ctx, value); }
    static int read_field( json_context &ctx, const std::string &name,  ::Binding_type &value ) \
    {
        PG_DIF_EX(0,address,"address")
        PG_DIF_EX(1,port,"port")
        return PGR_NIL;
    }
    static void write( json_context &ctx, const  ::Binding_type &value )
    {
        bool first = true;
        (*ctx.os) << '{';
        PG_SIF_EX(address,"address")
        PG_SIF_EX(port,"port")
        (*ctx.os) << '}';
    }
    static bool empty( const  ::Binding_type &value )
    {
        if (!json<decltype(value.address)>::empty(value.address)) return false;
        if (!json<decltype(value.port)>::empty(value.port)) return false;
        return true;
    }
    static void clear(  ::Binding_type &value )
    {
        json<decltype(value.address)>::clear(value.address);
        json<decltype(value.port)>::clear(value.port);
    }
    static bool equal( const  ::Binding_type &a, const  ::Binding_type &b )
    {
        if (!json<decltype(a.address)>::equal(a.address, b.address)) return false;
        if (!json<decltype(a.port)>::equal(a.port, b.port)) return false;
        return true;
    }
    static void swap(  ::Binding_type &a,  ::Binding_type &b )
    {
        json<decltype(a.address)>::swap(a.address, b.address);
        json<decltype(a.port)>::swap(a.port, b.port);
    }
    static bool is_missing( json_context &ctx )
    {
        std::string name;
        if (!(ctx.mask & 1)) { name = "address"; } else
        if (!(ctx.mask & 2)) { name = "port"; } else
        return false;
        ctx.tok->error(PGERR_MISSING_FIELD, std::string("Missing field '") + name + "'");
        return true;
    }
};}
PG_ENTITY(Binding, ::Binding_type,protogen_2_1_0::json< ::Binding_type>)
PG_ENTITY_SERIALIZER( ::Binding, ::Binding_type,protogen_2_1_0::json< ::Binding_type>)

//
// Cache
//
    struct Cache_type
    {
        protogen_2_1_0::field<int32_t> ttl;
        protogen_2_1_0::field<int32_t> limit;
    };
namespace protogen_2_1_0 {
template<> struct json< ::Cache_type>
{
    static int read( json_context &ctx,  ::Cache_type &value ) { return read_object(ctx, value); }
    static int read_field( json_context &ctx, const std::string &name,  ::Cache_type &value ) \
    {
        PG_DIF_EX(0,ttl,"ttl")
        PG_DIF_EX(1,limit,"limit")
        return PGR_NIL;
    }
    static void write( json_context &ctx, const  ::Cache_type &value )
    {
        bool first = true;
        (*ctx.os) << '{';
        PG_SIF_EX(ttl,"ttl")
        PG_SIF_EX(limit,"limit")
        (*ctx.os) << '}';
    }
    static bool empty( const  ::Cache_type &value )
    {
        if (!json<decltype(value.ttl)>::empty(value.ttl)) return false;
        if (!json<decltype(value.limit)>::empty(value.limit)) return false;
        return true;
    }
    static void clear(  ::Cache_type &value )
    {
        json<decltype(value.ttl)>::clear(value.ttl);
        json<decltype(value.limit)>::clear(value.limit);
    }
    static bool equal( const  ::Cache_type &a, const  ::Cache_type &b )
    {
        if (!json<decltype(a.ttl)>::equal(a.ttl, b.ttl)) return false;
        if (!json<decltype(a.limit)>::equal(a.limit, b.limit)) return false;
        return true;
    }
    static void swap(  ::Cache_type &a,  ::Cache_type &b )
    {
        json<decltype(a.ttl)>::swap(a.ttl, b.ttl);
        json<decltype(a.limit)>::swap(a.limit, b.limit);
    }
    static bool is_missing( json_context &ctx )
    {
        std::string name;
        if (!(ctx.mask & 1)) { name = "ttl"; } else
        if (!(ctx.mask & 2)) { name = "limit"; } else
        return false;
        ctx.tok->error(PGERR_MISSING_FIELD, std::string("Missing field '") + name + "'");
        return true;
    }
};}
PG_ENTITY(Cache, ::Cache_type,protogen_2_1_0::json< ::Cache_type>)
PG_ENTITY_SERIALIZER( ::Cache, ::Cache_type,protogen_2_1_0::json< ::Cache_type>)

//
// Configuration
//
    struct Configuration_type
    {
        std::vector< ::NameServer> external_dns;
         ::Binding binding;
        std::vector<std::string> blacklist;
        std::vector<std::string> whitelist;
        std::vector<std::string> monitoring;
        protogen_2_1_0::field<int32_t> monitoring_;
        std::string dump_path_;
        protogen_2_1_0::field<int32_t> threads;
         ::Cache cache;
        protogen_2_1_0::field<bool> use_heuristics;
        protogen_2_1_0::field<bool> use_ipv6;
    };
namespace protogen_2_1_0 {
template<> struct json< ::Configuration_type>
{
    static int read( json_context &ctx,  ::Configuration_type &value ) { return read_object(ctx, value); }
    static int read_field( json_context &ctx, const std::string &name,  ::Configuration_type &value ) \
    {
        PG_DIF_EX(0,external_dns,"external_dns")
        PG_DIF_EX(1,binding,"binding")
        PG_DIF_EX(2,blacklist,"blacklist")
        PG_DIF_EX(3,whitelist,"whitelist")
        PG_DIF_EX(4,monitoring,"monitoring")
        PG_DIF_EX(7,threads,"threads")
        PG_DIF_EX(8,cache,"cache")
        PG_DIF_EX(9,use_heuristics,"use_heuristics")
        PG_DIF_EX(10,use_ipv6,"use_ipv6")
        return PGR_NIL;
    }
    static void write( json_context &ctx, const  ::Configuration_type &value )
    {
        bool first = true;
        (*ctx.os) << '{';
        PG_SIF_EX(external_dns,"external_dns")
        PG_SIF_EX(binding,"binding")
        PG_SIF_EX(blacklist,"blacklist")
        PG_SIF_EX(whitelist,"whitelist")
        PG_SIF_EX(monitoring,"monitoring")
        PG_SIF_EX(threads,"threads")
        PG_SIF_EX(cache,"cache")
        PG_SIF_EX(use_heuristics,"use_heuristics")
        PG_SIF_EX(use_ipv6,"use_ipv6")
        (*ctx.os) << '}';
    }
    static bool empty( const  ::Configuration_type &value )
    {
        if (!json<decltype(value.external_dns)>::empty(value.external_dns)) return false;
        if (!json<decltype(value.binding)>::empty(value.binding)) return false;
        if (!json<decltype(value.blacklist)>::empty(value.blacklist)) return false;
        if (!json<decltype(value.whitelist)>::empty(value.whitelist)) return false;
        if (!json<decltype(value.monitoring)>::empty(value.monitoring)) return false;
        if (!json<decltype(value.monitoring_)>::empty(value.monitoring_)) return false;
        if (!json<decltype(value.dump_path_)>::empty(value.dump_path_)) return false;
        if (!json<decltype(value.threads)>::empty(value.threads)) return false;
        if (!json<decltype(value.cache)>::empty(value.cache)) return false;
        if (!json<decltype(value.use_heuristics)>::empty(value.use_heuristics)) return false;
        if (!json<decltype(value.use_ipv6)>::empty(value.use_ipv6)) return false;
        return true;
    }
    static void clear(  ::Configuration_type &value )
    {
        json<decltype(value.external_dns)>::clear(value.external_dns);
        json<decltype(value.binding)>::clear(value.binding);
        json<decltype(value.blacklist)>::clear(value.blacklist);
        json<decltype(value.whitelist)>::clear(value.whitelist);
        json<decltype(value.monitoring)>::clear(value.monitoring);
        json<decltype(value.monitoring_)>::clear(value.monitoring_);
        json<decltype(value.dump_path_)>::clear(value.dump_path_);
        json<decltype(value.threads)>::clear(value.threads);
        json<decltype(value.cache)>::clear(value.cache);
        json<decltype(value.use_heuristics)>::clear(value.use_heuristics);
        json<decltype(value.use_ipv6)>::clear(value.use_ipv6);
    }
    static bool equal( const  ::Configuration_type &a, const  ::Configuration_type &b )
    {
        if (!json<decltype(a.external_dns)>::equal(a.external_dns, b.external_dns)) return false;
        if (!json<decltype(a.binding)>::equal(a.binding, b.binding)) return false;
        if (!json<decltype(a.blacklist)>::equal(a.blacklist, b.blacklist)) return false;
        if (!json<decltype(a.whitelist)>::equal(a.whitelist, b.whitelist)) return false;
        if (!json<decltype(a.monitoring)>::equal(a.monitoring, b.monitoring)) return false;
        if (!json<decltype(a.monitoring_)>::equal(a.monitoring_, b.monitoring_)) return false;
        if (!json<decltype(a.dump_path_)>::equal(a.dump_path_, b.dump_path_)) return false;
        if (!json<decltype(a.threads)>::equal(a.threads, b.threads)) return false;
        if (!json<decltype(a.cache)>::equal(a.cache, b.cache)) return false;
        if (!json<decltype(a.use_heuristics)>::equal(a.use_heuristics, b.use_heuristics)) return false;
        if (!json<decltype(a.use_ipv6)>::equal(a.use_ipv6, b.use_ipv6)) return false;
        return true;
    }
    static void swap(  ::Configuration_type &a,  ::Configuration_type &b )
    {
        json<decltype(a.external_dns)>::swap(a.external_dns, b.external_dns);
        json<decltype(a.binding)>::swap(a.binding, b.binding);
        json<decltype(a.blacklist)>::swap(a.blacklist, b.blacklist);
        json<decltype(a.whitelist)>::swap(a.whitelist, b.whitelist);
        json<decltype(a.monitoring)>::swap(a.monitoring, b.monitoring);
        json<decltype(a.monitoring_)>::swap(a.monitoring_, b.monitoring_);
        json<decltype(a.dump_path_)>::swap(a.dump_path_, b.dump_path_);
        json<decltype(a.threads)>::swap(a.threads, b.threads);
        json<decltype(a.cache)>::swap(a.cache, b.cache);
        json<decltype(a.use_heuristics)>::swap(a.use_heuristics, b.use_heuristics);
        json<decltype(a.use_ipv6)>::swap(a.use_ipv6, b.use_ipv6);
    }
    static bool is_missing( json_context &ctx )
    {
        std::string name;
        if (!(ctx.mask & 1)) { name = "external_dns"; } else
        if (!(ctx.mask & 2)) { name = "binding"; } else
        if (!(ctx.mask & 4)) { name = "blacklist"; } else
        if (!(ctx.mask & 8)) { name = "whitelist"; } else
        if (!(ctx.mask & 16)) { name = "monitoring"; } else
        if (!(ctx.mask & 128)) { name = "threads"; } else
        if (!(ctx.mask & 256)) { name = "cache"; } else
        if (!(ctx.mask & 512)) { name = "use_heuristics"; } else
        if (!(ctx.mask & 1024)) { name = "use_ipv6"; } else
        return false;
        ctx.tok->error(PGERR_MISSING_FIELD, std::string("Missing field '") + name + "'");
        return true;
    }
};}
PG_ENTITY(Configuration, ::Configuration_type,protogen_2_1_0::json< ::Configuration_type>)
PG_ENTITY_SERIALIZER( ::Configuration, ::Configuration_type,protogen_2_1_0::json< ::Configuration_type>)
#endif // GUARD__source_config_proto
